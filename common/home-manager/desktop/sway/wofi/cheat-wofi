#!/usr/bin/env bash
#
# wofi-navi - Use navi cheats with wofi

# Set safer bash defaults
set -o errexit  # Exit on error
set -o nounset  # Error on unset variables
set -o pipefail # Fail pipe chains if any command fails

# Configuration
CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/wofi-navi"
mkdir -p "$CACHE_DIR"
CACHE_TTL=3600  # Cache entries for 1 hour

# Make sure navi is installed
if ! command -v navi &>/dev/null; then
    notify-send -u critical "Error" "navi is not installed"
    exit 1
fi

# Make sure wofi is installed
if ! command -v wofi &>/dev/null; then
    notify-send -u critical "Error" "wofi is not installed"
    exit 1
fi

# Function to get list of navi cheatsheet repositories
get_cheatsheet_repos() {
    local cache_file="${CACHE_DIR}/repos.cache"
    
    # Check if cache exists and is recent
    if [[ -f "$cache_file" && $(($(date +%s) - $(stat -c %Y "$cache_file"))) -lt $CACHE_TTL ]]; then
        cat "$cache_file"
        return
    fi
    
    # Get repos from navi
    navi repo list | grep -v "^No repositories found" | awk '{print $1}' | sort > "$cache_file"
    cat "$cache_file"
}

# Function to get all cheatsheet entries from a repo
get_repo_cheats() {
    local repo="$1"
    local cache_file="${CACHE_DIR}/repo_${repo// /_}.cache"
    
    # Check if cache exists and is recent
    if [[ -f "$cache_file" && $(($(date +%s) - $(stat -c %Y "$cache_file"))) -lt $CACHE_TTL ]]; then
        cat "$cache_file"
        return
    fi
    
    # Query navi for this repo and format as JSON
    navi --print --query "$repo" | navi --tldr --find-command | jq -r '.[] | .tags[0] + ":" + .command + ":" + .description' > "$cache_file"
    cat "$cache_file"
}

# Function to search across all cheatsheets
search_all_cheats() {
    local query="$1"
    local cache_file="${CACHE_DIR}/search_${query// /_}.cache"
    
    # For searches, use a shorter cache TTL or skip cache for freshness
    if [[ -f "$cache_file" && $(($(date +%s) - $(stat -c %Y "$cache_file"))) -lt 300 ]]; then
        cat "$cache_file"
        return
    fi
    
    # Use navi to search and format results
    navi --print --query "$query" | navi --tldr --find-command | jq -r '.[] | .tags[0] + ":" + .command + ":" + .description' > "$cache_file"
    cat "$cache_file"
}

# Smart parameter replacement
replace_parameters() {
    local cmd="$1"
    local replaced="$cmd"
    local params=()

    # Extract all parameters at once
    while [[ "$replaced" =~ \<([^>]+)\>|\{([^}]+)\}|\[([^]]+)\]|\$([A-Z_][A-Z0-9_]*) ]]; do
        local full_match="${BASH_REMATCH[0]}"
        local param="${BASH_REMATCH[1]:-${BASH_REMATCH[2]:-${BASH_REMATCH[3]:-${BASH_REMATCH[4]}}}}"

        # Check if we already have this parameter
        local found=0
        for i in "${!params[@]}"; do
            if [[ "${params[$i]}" == "$full_match" ]]; then
                found=1
                break
            fi
        done

        [[ $found -eq 0 ]] && params+=("$full_match")

        # Temporarily replace to continue finding others
        replaced="${replaced//$full_match/__PARAM__}"
    done

    # If no parameters, return original
    [[ ${#params[@]} -eq 0 ]] && echo "$cmd" && return 0

    # Single input for all parameters
    local prompt="Enter values for: ${params[*]}"
    local input
    input=$(wofi --dmenu -p "$prompt" -l 1)
    [[ -z "$input" ]] && return 1

    # Split input by spaces (user can quote values with spaces)
    local values=()
    eval "values=($input)"

    # Replace parameters with values
    local result="$cmd"
    for i in "${!params[@]}"; do
        local param="${params[$i]}"
        local value="${values[$i]:-}"

        if [[ "$param" =~ ^\[ ]] && [[ -z "$value" ]]; then
            result="${result//$param/}"
        else
            result="${result//$param/$value}"
        fi
    done

    # Clean up spaces
    result=$(echo "$result" | sed 's/  \+/ /g' | sed 's/^ *//;s/ *$//')
    echo "$result"
}

# Execute, copy, or open in terminal
handle_command() {
    local cmd="$1"
    local action="${2:-action_menu}"
    local terminal="${AI_WOFI_TERMINAL:-foot}"
    
    # Process the command with parameter replacement if needed
    cmd=$(replace_parameters "$cmd")
    [[ -z "$cmd" ]] && exit 0
    
    # If action is 'action_menu', show the action menu first
    if [[ "$action" == "action_menu" ]]; then
        action=$(printf "Execute command\nCopy to clipboard\nOpen in terminal" | wofi --dmenu -p "Command Action:" -l 3)
    fi
    
    case "$action" in
        "Execute command"|execute)
            notify-send -t 3000 "Executing" "$cmd"
            eval "$cmd"
            ;;
        "Copy to clipboard"|copy)
            echo -n "$cmd" | wl-copy
            notify-send -t 2000 "Copied to clipboard" "$cmd"
            ;;
        "Open in terminal"|terminal)
            # Determine which terminal to use
            if command -v "$terminal" &>/dev/null; then
                notify-send -t 2000 "Opening in terminal" "$cmd"
                # Different terminals have different ways to set initial command
                case "$terminal" in
                    foot|alacritty)
                        $terminal -e bash -c "$cmd; echo -e '\nCommand completed. Press Enter to close.'; read"
                        ;;
                    kitty)
                        kitty -e bash -c "$cmd; echo -e '\nCommand completed. Press Enter to close.'; read"
                        ;;
                    gnome-terminal)
                        gnome-terminal -- bash -c "$cmd; echo -e '\nCommand completed. Press Enter to close.'; read"
                        ;;
                    xterm)
                        xterm -e bash -c "$cmd; echo -e '\nCommand completed. Press Enter to close.'; read"
                        ;;
                    konsole)
                        konsole -e bash -c "$cmd; echo -e '\nCommand completed. Press Enter to close.'; read"
                        ;;
                    *)
                        # Generic approach for other terminals
                        $terminal -e bash -c "$cmd; echo -e '\nCommand completed. Press Enter to close.'; read"
                        ;;
                esac
            else
                notify-send -u critical "Terminal not found" "Could not find terminal: $terminal"
            fi
            ;;
    esac
}

# Main instant menu
main() {
    # Build instant menu with sheets and actions
    local sheets
    sheets=$(get_cheatsheet_list)

    # Create menu entries
    local menu_entries=""

    # Add quick search option at top
    menu_entries="üîç Search all sheets\n"

    # Add all sheets
    while IFS= read -r sheet; do
        menu_entries+="üìÑ $sheet\n"
    done <<< "$sheets"

    # Show instant menu
    local selected
    selected=$(echo -e "$menu_entries" | wofi --dmenu -i -p "Cheat" -W 40% -l 20 --matching fuzzy)

    [[ -z "$selected" ]] && exit 0

    # Handle selection
    if [[ "$selected" == "üîç Search all sheets" ]]; then
        # Search mode - ask for search term first
        local search_term
        search_term=$(wofi --dmenu -p "Search for:")
        [[ -z "$search_term" ]] && exit 0

        # Search in cheat directly (fast)
        local results
        results=$(cheat -s "$search_term" 2>/dev/null | awk -v term="$search_term" '
            /^[^\/]*\.cheat$/ {
                if (match($0, /([^\/]+)\.cheat$/, m)) {
                    current_sheet = m[1]
                }
                next
            }
            /^\s*[0-9]+:/ {
                # Remove line number
                gsub(/^\s*[0-9]+:\s*/, "")
                # Skip empty lines
                if (length($0) == 0) next
                # Skip pure comments
                if (/^#[^$]/ && !/$/) next
                # Add sheet prefix
                print "[" current_sheet "] " $0
            }
        ')

        if [[ -z "$results" ]]; then
            notify-send "No results" "No commands found for: $search_term"
            exit 0
        fi

        # Build a mapping between display text and actual commands
        declare -A cmd_map
        local formatted_results=""
        
        # Process each search result
        while IFS= read -r line; do
            if [[ "$line" =~ ^\[(.*)\]\ (.*?)\ #\ (.*)$ ]]; then
                # Command with description - parse components
                local sheet_name="${BASH_REMATCH[1]}"
                local cmd_part="${BASH_REMATCH[2]}"
                local desc_part="${BASH_REMATCH[3]}"
                
                # Create display string with command and description
                local display_string="$cmd_part  ¬´  $desc_part"
                
                # Store mapping between display string and raw command
                cmd_map["$display_string"]="$cmd_part"
                
                # Add to formatted output
                formatted_results+="$display_string\n"
            elif [[ "$line" =~ ^\[(.*)\]\ (.*)$ ]]; then
                # Command without description
                local sheet_name="${BASH_REMATCH[1]}"
                local cmd_part="${BASH_REMATCH[2]}"
                
                # Store mapping (same value for key and value)
                cmd_map["$cmd_part"]="$cmd_part"
                
                # Add to formatted output
                formatted_results+="$cmd_part\n"
            else
                # Skip invalid lines
                continue
            fi
        done <<< "$results"

        # Show formatted results
        local cmd_selected
        cmd_selected=$(echo -e "$formatted_results" | wofi --dmenu -i -p "Results for: $search_term" -W 80% -l 20)
        [[ -z "$cmd_selected" ]] && exit 0

        # Look up the actual command from our mapping
        local cmd="${cmd_map["$cmd_selected"]}"
        
        # If not found in map (shouldn't happen), try to extract it
        if [[ -z "$cmd" ]]; then
            if [[ "$cmd_selected" =~ ^(.*?)\ \ ¬´\ \ .*$ ]]; then
                cmd="${BASH_REMATCH[1]}"
            else
                cmd="$cmd_selected"
            fi
        fi
        # Handle the command with our action menu
        handle_command "$cmd" "action_menu"

    elif [[ "$selected" =~ ^üìÑ[[:space:]](.+)$ ]]; then
        # Sheet selected - parse just this sheet
        local sheet="${BASH_REMATCH[1]}"
        local commands
        commands=$(parse_cheatsheet "$sheet")

        # Build a mapping between display text and actual commands
        declare -A cmd_map
        local formatted_commands=""
        
        # Process each line
        while IFS= read -r line; do
            if [[ "$line" =~ ^\[(.*)\]\ (.*?)\ #\ (.*)$ ]]; then
                # Command with description - parse components
                local sheet_name="${BASH_REMATCH[1]}"
                local cmd_part="${BASH_REMATCH[2]}"
                local desc_part="${BASH_REMATCH[3]}"
                
                # Create display string with command and description
                local display_string="$cmd_part  ¬´  $desc_part"
                
                # Store mapping between display string and raw command
                cmd_map["$display_string"]="$cmd_part"
                
                # Add to formatted output
                formatted_commands+="$display_string\n"
            elif [[ "$line" =~ ^\[(.*)\]\ (.*)$ ]]; then
                # Command without description
                local sheet_name="${BASH_REMATCH[1]}"
                local cmd_part="${BASH_REMATCH[2]}"
                
                # Store mapping (same value for key and value)
                cmd_map["$cmd_part"]="$cmd_part"
                
                # Add to formatted output
                formatted_commands+="$cmd_part\n"
            else
                # Skip invalid lines
                continue
            fi
        done <<< "$commands"

        # Show formatted commands from this sheet
        local cmd_selected
        cmd_selected=$(echo -e "$formatted_commands" | wofi --dmenu -i -p "[$sheet]" -W 80% -l 25 --matching fuzzy)
        [[ -z "$cmd_selected" ]] && exit 0

        # Look up the actual command from our mapping
        local cmd="${cmd_map["$cmd_selected"]}"
        
        # If not found in map (shouldn't happen), try to extract it
        if [[ -z "$cmd" ]]; then
            if [[ "$cmd_selected" =~ ^(.*?)\ \ ¬´\ \ .*$ ]]; then
                cmd="${BASH_REMATCH[1]}"
            else
                cmd="$cmd_selected"
            fi
        fi

        # Handle the command with our action menu
        handle_command "$cmd" "action_menu"
    fi
}

# Clear cache if requested
if [[ -n "${1:-}" && "$1" == "--clear-cache" ]]; then
    rm -rf "$CACHE_DIR"
    echo "Cache cleared"
    exit 0
fi

# Direct sheet access
if [[ -n "${1:-}" && "$1" == "-s" ]] && [[ -n "${2:-}" ]]; then
    commands=$(parse_cheatsheet "$2")
    cmd_selected=$(echo "$commands" | wofi --dmenu -i -p "[$2]" -W 80% -l 25 --matching fuzzy)
    [[ -n "$cmd_selected" ]] && {
        cmd=$(echo "$cmd_selected" | sed 's/^\[[^]]*\] //' | sed 's/ *#.*//')
        handle_command "$cmd"
    }
    exit 0
fi

main "$@"
